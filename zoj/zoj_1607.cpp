/*
	差值博弈  极大极小博弈  好题

	题意：盒子里有n个圆饼，两个人轮流从盒子中拿出一些圆饼，至少拿一个，至多m个。当一个人在某一轮拿走盒子中所有的圆饼后，他吃掉自己拿走的圆饼，另一个人把他拿到的圆饼全部放回盒子中。然后游戏重新开始，由没有吃圆饼的那个人先开始。当所有的圆饼全部被吃掉后，游戏结束。假设双方都采取最优策略，求先手吃掉圆饼的最大值。

	思路：题目要求先手的最大值，可以转换成求先手-后手的最大值，因为总的圆饼数量为n，所有先手的最大值 = (ans+n) / 2
	 	  设dp[n][j][k]为还没被吃掉的饼为n个，前后之前取了j个，后手之前取了k个，先手-后手的最大值

		  (1) 先手可以一次性拿走盒子中所有饼，即盒子中剩余饼不足n
		  	  f[n][j][k] = max{-f[k][0][0] + n-k}	//不足n，所以先手肯定直接取完，先手就能吃掉j+(n-j-k) = n-k个饼。然后接下来是后手作为总数为k的新一轮的先手。        易证明此时先手肯定直接取完，这是DP无后效性和最优性的关键
		  (2) f[n][j][k] = max{-f[n][k][j+x]}, 1 <= x <= n, j+k+x < i，先手取x个，轮到后手

		  最后ans = (f[n][0][0] + n) / 2



		  感觉这个状态表示好奇葩......
		  
		  * *************************************************** *
		  * 题目要求先手的最大值，可以转化为求先手-后手的最大值 *
		  *														*
		  * *************************************************** *
*/
//zoj 1607
#include <algorithm>
#include <stdio.h>
#include <string.h>
using namespace std;

int m, dp[105][105][105], oo;
int DP(int n, int j, int k)
{
	if(dp[n][j][k] != oo) return dp[n][j][k];
	if(n-j-k <= m) return -DP(k, 0, 0) + n-k;
	int ans = oo;
	for(int i = 1; i <= m && j+k+i <= n; i++) {
		ans = max(ans , -DP(n, k, j+i));
	}
	return dp[n][j][k] = ans;
}
int main()
{
	memset(&oo, 128, sizeof(oo));
	int n;
	while(scanf("%d %d", &n, &m) != EOF) {
		memset(dp, 128, sizeof dp);
		dp[0][0][0] = 0;
		printf("%d\n", (DP(n, 0, 0)+n)/2);
	}
	return 0;
}
