/*
    思路题  博弈论  图论  好题

    题意：一个无向带点权带边权图，Alice和Bob轮着选取没有被选过的点，选到的点的权值作为分数加给游戏者。如果两个相邻的点被同一人选取到，则这两点之间的边也作为额外权值赋给游戏者。假设Alice和Bob都使用最优策略，问最后的Alice - Bob分数的结果。

    思路：哪来的思路呀...比赛的时候哪想得到这个解法呀...只能说大家怎么都这么聪明呀...算法题也就算了，这可是思路题呀，大家都怎么想到的喂...我真的那么笨吗喂喂喂...=_=
          还是黄牛给我讲了他的思考过程：n <= 10^5，要么搜索，要么生成树；在搜索这边啃了很久啃不出来想生成树，生成树果断想kruskal，因为prim的更新耗时，在n=10^5的数量级是过不了的；想到拆边，拆成正负边权，w/-w；但两个点的关系没联系到一起，没搞好；刷了一会儿游戏=_=；把边权和点权同一起来，就是把边权加到点权上；用刚才的拆成正负边显然不行；灵光一闪，把边拆成1/2, 1/2就可以了，因为他想到了一个数学规律：把一个数拆成两半，这两半相加为原数，相减为0。
          

          下面就直接贴题解的原话吧：
          若没有边权，则对点权从大到小排序即可。。

          考虑边，将边权拆成两半加到它所关联的两个点的点权中即可。

          因为当两个人分别选择不同的点时，这一权值将互相抵消。


*/
#include <stdio.h>
#include <algorithm>
using namespace std;
int n, m;
double w[100005];

int main()
{
    int u, v;
    double wi;
    while(scanf("%d%d", &n, &m) != EOF) {
        for(int i = 1; i <= n; i++) scanf("%lf", &w[i]);
        while(m--) {
            scanf("%d%d%lf", &u, &v, &wi);
            w[u] += wi/2;
            w[v] += wi/2;
        }
        sort(w+1, w+1+n);
        double ans = 0;
        for(int i = n; i >= 2; i -= 2) ans += w[i] - w[i-1];
        printf("%I64d\n", (long long)ans);
    }
    return 0;
}
