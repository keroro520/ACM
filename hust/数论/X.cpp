/*
	概率论  组合数学  推公式  好题
	题意：n/2个汉堡，n/2个起司，分给n个人，按顺序投硬币决定是要汉堡还是要起司。问最后两个人得到同样食物的概率

	思路：我们直接算所求概率是比较麻烦的，要考虑硬币抛到谁之后就不再抛了。但我们反过来求不合要求的概率就比较简单了，即最后两个人得到不同食物的概率，因为必然硬币到了最后时刻还在抛，那么对于任意一种最终不符合要求的情况，都是等概率事件。
		  那么我们只要把不合要求的情况找到，再乘上每种情况的概率即可：
		  一共有2^(n-2)种情况（最后两人是不计在内的），所以每种情况的概率为2^-(n-2)
		  不合要求的情况，必然是前n-2个人分别那道n/2-1个汉堡，n/2-1个起司，所以共有C( n/2-1, n-2 )种情况，即在前n-2个位置选出n/2-1个位置放置汉堡。
		  得f(n) = 2^(2-n) * C( (n/2)/2, n-2 )
		  直接计算据说精度会挂掉，或者TLE。“受组合数的递推计算式的启发，对于f(n)的计算我们是否也可以用递推的方式计算呢？显然可以，因为我们有了f(n)的通项公式嘛，而且化成递推式后，我们会发现它出乎意料得简练 ”
		  组合数递推公式: C(n,k+1) = C(n,k) * (n-k)/(k+1)
		  f(n)   = 2^(2-n) * C((n-2)/2, n-2)
		  f(n+2) = 2^(-n)  * C(n/2, n)


	                      2^2 * C( (n-2)/2, n-2 )        (n-2)!			      n/2! * n/2!	       (n/2) * (n/2)        n
		  f(n) / f(n+2) = ------------------------   =  ------------------  * ------------------ = ------------------ = -----
                                C( n/2    ,  n  )        (n-2)/2! * (n-2)/2!  n!				   (n-1) * n            4*(n-1)
		  
		  so, f(n+2) = f(n) * (n-1)/n


		  http://www.cnblogs.com/staginner/archive/2011/12/13/2286151.html
		  http://blog.csdn.net/sdust_dc/article/details/9616173
*/
#include <stdio.h>
double f[100005];

void init()
{
	f[2] = 1;
	for(int i = 2; i < 100000; i += 2)
		f[i+2] = f[i] * (i-1) / i;
}
int main()
{
	int n, cases;
	init();
	scanf("%d", &cases);
	while(cases--) {
		scanf("%d", &n);
		printf("%.4f\n", 1 - f[n]);
	}
	return 0;
}
