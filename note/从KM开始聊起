
那个SLACK[]精确维护好像不是必须的 
哲彬 00:29:04
我每道题都删了都能AC 
那精确维护它的必要性在哪？ 
哲彬 00:29:22
百度百科为啥要特别提示要精确维护 
笨蛋侦探 00:29:27
时间上减少？
哲彬 00:29:34
反而增加了 
我刚才看了一下我看的模板题解。    （我是照着模板抄的。）
发现他原来是有else的后来注释掉了。
                if(1 == visr[i]) 
     pr[i] += d; 
 //else
    stack[i] -= d; 
笨蛋侦探 00:34:26
不知道他为什么注释掉。
哲彬 00:34:33
注释掉能快 
哲彬 00:34:54
下一轮DFS又正确算出来了 
哲彬 00:34:57
没必要- 
-了只是让人感觉很精确很舒服很放心 
哲彬 00:35:16
这是我的理解 
笨蛋侦探 00:35:24
啊。。我犯晕了。。那加else才是正解是吧？
哲彬 00:35:30
加不加等价 
哲彬 00:35:36
我试了好多题了 
哲彬 00:35:39
自己也想了 
哲彬 00:35:41
是等价 
哲彬 00:36:01
下一轮DFS又算好了 
slack精确维护必要性， 一直想找研究过的证实一下 
笨蛋侦探 00:39:35
其实我原本是想在这一句后面加上注释“visy[j] == true说明j 在交错树上，则LY[j] += d, slack[j] -= d；   slack[j] -= d表示j 的可松弛量剪 d，”
也就是说我对slack[]的理解是表示Y部的可松弛量。这样理解的话应该是不加else才对呀。
哲彬 00:40:11
。 slack[]是Y部非交错树点上的标记 
哲彬 00:40:36
每次DFS过后执行-+操作， X-=d, Y+=d 
哲彬 00:40:53
目的是想让Y部树外的点进入相等子图 
哲彬 00:41:05
。 SLACK是树外的标记 
哲彬 00:41:14
所以修改树内是没有意义的 
笨蛋侦探 00:41:22
对呀，跟“可松弛量”一个意思。因为把 一部分 d 加如到交错树里了，那非交错树就少了 d 了。所以是减。
!visy[j]) slack[j] -= tmp 
哲彬 00:42:06
这才是Y部树外点 
哲彬 00:42:37
。。。 你看两行代码就知道了 
哲彬 00:42:53
访问slack的地方只有这里
if(!visy[j]) tmp = min(tmp, slack[j]); 
哲彬 00:43:09
if(visy[j]) slack[j] -= tmp
所以这里的修改永远不会被用到 
笨蛋侦探 00:43:47
咦。。对耶。。
哲彬 00:43:55
对吧 
哲彬 00:44:25
前一轮能visy[j]=true的j， 下一次仍然visy[j] = true 
笨蛋侦探 00:44:49
嗯。
哲彬 00:45:22
所以说 
你有没有看出KM算法的设计理念 
哲彬 00:45:33
我给你一句话真相 
笨蛋侦探 00:46:08
没。
哲彬 00:46:40
KM跟网络流很像 
哲彬 00:46:53
流网络有一个性质 
哲彬 00:46:58
任意流小于任意割 
哲彬 00:47:07
所以一旦找到一个流等于一个割 
哲彬 00:47:17
马上得出该流是最大流，该割是最小割 
哲彬 00:47:35
因为没有流能大于这个割了， 也没有割能小于这个流了 
哲彬 00:47:40
KM也是这样 
二分图的任意匹配 小于 任意标号和 
哲彬 00:48:26
所以一旦找到一个匹配等于一个标号和 
哲彬 00:48:43
马上得出该匹配是最大权匹配， 该标号和是最小标号和 
哲彬 00:49:05
这是标号和的性质导出的 
哲彬 00:49:50
小于 -》 小于等于 
笨蛋侦探 00:50:00
哇~~Nice！  分析得很清晰。
哲彬 00:50:05
是吧 
哲彬 00:50:13
有了这些不难想SLACK这一堆了 
哲彬 00:50:17
从理念入手 
哲彬 00:50:51
    int rest = LX[u] + LY[v] - edge[k].w; 
所以这个式子长这样 
哲彬 00:51:11
边权老想从下面逼近标号和 
哲彬 00:51:30
这个算法的 匹配值 和标号和是逐渐逼近的 
哲彬 00:51:37
我打印出来看过 
哲彬 00:52:37
。。。 不行了我思路有点不清了。。 
哲彬 00:52:43
割太多题 
哲彬 00:52:48
后面可能不对你甄别下 
笨蛋侦探 00:52:54
嗯。
哲彬 00:54:20
neko13  00:51:12
边权老想从下面逼近标号和
这个算法的 匹配值 和标号和是逐渐逼近的
我打印出来看过 
哲彬 00:54:25
我更正下这部分 
哲彬 00:56:11
看起来是相互逼近 
哲彬 00:56:14
这样理解对吗 
哲彬 00:56:21
我刚刚才观察得出的 
哲彬 00:56:32
匹配不断增加 
哲彬 00:56:37
标号和不断减小 
哲彬 00:56:43
直到两者相等 
笨蛋侦探 00:56:46
我不知道。。但是这种性质都被你抓出来

哲彬 00:57:03
我前面看KM只发现了标号和减小就丢一边了 
哲彬 00:57:08
刚发你总结的时候 
哲彬 00:57:16
发现匹配权和可以看成是增加的 
哲彬 00:57:24
然后这个算法的动态挺有趣的 
哲彬 00:57:38
相等算法就结束 
哲彬 00:59:23
其实这好像是我看最小最大论文 才发现的 
哲彬 00:59:28
KM算法的设计理念 
哲彬 00:59:34
最小最大有一个套路 
哲彬 01:00:05


如果A里面的东西 <= B里面的东西


并且找到了一个A=B 
哲彬 01:00:12
那么找到的是最大A， 最小B 

