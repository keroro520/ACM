
(0)  KM的理解
/*
***kuangbin强调：
    1 KM算法用来解决最大权匹配问题： 在一个二分图内，左顶点为X，右顶点为Y，现对于每组左右连接XiYj有权wij，求一种匹配使得所有wij的和最大

    2 也就是最大权匹配一定是完备匹配。如果两边的点数相等则是完美匹配

    3 如果点数不相等，其实可以虚拟一些点，使得点数相等，也成为了完美匹配

***注意几点：
    *1 对于任一条边(i,j)，A[i]+B[j]>=w[i,j]始终成立.
    *2 (A[i]+B[j])是从大试到小的，所以第一次匹配到的结果才是最优匹配.
    *3 我们求当前相等子图的完备匹配失败了，是因为对于某个X顶点，我们找不到一条从它出发的交错路。这时我们获得了一棵交错树，它的叶子结点全部是X顶点。现在我们把交错树中X顶点的顶标全都减小某个值d，Y顶点的顶标全都增加同一个值d，那么我们会发现：
        1）两端都在交错树中的边(i,j)，A[ i ]+B[j]的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图
        2）两端都不在交错树中的边(i,j)，A[ i ]和B[j]都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图
        3）X端不在交错树中，Y端在交错树中的边(i,j)，它的A[ i ]+B[j]的值有所增大。它原来不属于相等子图，现在仍不属于相等子图
        4）X端在交错树中，Y端不在交错树中的边(i,j)，它的A[ i ]+B[j]的值有所减小。也就说，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大



***KM的相关定理:

    设 G(V,E) 为二部图， G'(V,E') 为二部图的子图。如果对于 G' 中的任何边<x,y> 满足， L(x)+ L(y)== Wx,y，我们称 G'(V,E') 为 G(V,E) 的等价子图或相等子图（是G的生成子图）.
    若由二分图中所有满足A[i]+B[j]=w[i,j]的边(i,j)构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。


***情况：
        KM算法是求最大权完备匹配，如果要求最小权完备匹配怎么办？方法很简单，只需将所有的边权值取其相反数，求最大权完备匹配，匹配的值再取相反数即可。
        KM算法的运行要求是必须存在一个完备匹配，如果求一个最大权匹配(不一定完备)该如何办？依然很简单，把不存在的边权值赋为0。

        KM算法求得的最大权匹配是边权值和最大，如果我想要边权之积最大，又怎样转化？还是不难办到，每条边权取自然对数，然后求最大和权匹配，求得的结果a再算出e^a就是最大积匹配。至于精度问题则没有更好的办法了。

bool find(int u)
{
    visitx[u] = true;
    for(int i = 1; i <= N; i++) if(!visity[i]) {
        int rest = X[u] + Y[i] - g[u][i];           //判断有没有边不是直接查表，而是看X[u] + Y[i] == g[u][i] 
        if(rest == 0) {
            visity[i] = true;
            if(link[i] == -1 || find(link[i])) {
                link[i] = u;
                return true;
            }
        } else slack = min(slack, rest);
    }
    return false;
}
void KM()
{
    memset(X, 0, sizeof(X));
    memset(Y, 0, sizeof(Y));
    for(int i = 1; i <= N; i++) 
        for(int j = 1; j <= N; j++)
            X[i] = max(X[i], g[i][j]);

    for(int i = 1; i <= N; i++) {
        while(true) {
            memset(visitx, false, sizeof(visitx));
            memset(visity, false, sizeof(visity));
            slack = INT_MAX;
            if(find(i)) break;
            else {                                  //如果找不到增广路就更新顶标
                for(int j = 1; j <= N; j++) {
                    if(visitx[j]) X[j] -= slack;
                    if(visity[j]) Y[j] += slack;
                }
            }
        }
    }
}

*/
//================  下面这是改进的slack数组版本的KM  ==================================================================
bool find(int u)
{
    visx[u] = true;
    for(int k = head[u]; k != -1; k = edge[k].next) {
        int v = edge[k].v;
        if(visy[v]) continue;
        int rest = LX[u] + LY[v] - edge[k].w;
        if(rest == 0) {
            visy[v] = true;
            if(link[v] == -1 || find(link[v])) {
                link[v] = u;
                ans[v]  = k;        //记录边
                return true;
            }
        } else slack[v] = min(slack[v], rest);  //u在交错树，v不在交错树，更新d  也就是说边(u,v)不在相等子图中
    }
    return false;
}
bool KM()
{
    memset(LX, 128, sizeof(LX));        //最大匹配
    memset(LY,   0, sizeof(LY));
    memset(link, -1,sizeof(link));
    for(int i = 1; i <= n; i++)
        for(int k = head[i]; k != -1; k = edge[k].next) {
            LX[i] = max(LX[i], edge[k].w);
        }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) slack[j] = INF;
        while(true) {
            memset(visx, false, sizeof(visx));
            memset(visy, false, sizeof(visy));
            if(find(i)) break;
            else {
                int tmp = INF;
                for(int j = 1; j <= m; j++) if(!visy[j]) tmp = min(tmp, slack[j]);
                if(tmp == INF) return false;         //无法松弛，找不到完备匹配     TODO TODO 这里判断是否有完备匹配
                for(int j = 1; j <= n; j++) if(visx[j]) LX[j] -= tmp;
                for(int j = 1; j <= m; j++) 
                    if(visy[j]) LY[j] += tmp;
                    else slack[j] -= tmp;       //修改顶标后，要把所有的不在交错树中的Y顶点的slack值都减去d。
            }
        }
    }
    return true;
}
//==============================================================================================================
(1) 二分图多重匹配  启发题  hdu_3605
/*
    题意：题意：末日逃亡，n个人逃往m个星球，一个人只能在某些星球上>生存。一个星球最多居住人口有上限。求最后是否可以让所有人都逃离地球

    思路：一般的二分图匹配是一对一的，link[]贮存Y部的匹配点。
          这道题是多对一的，也就是星球能与多个人同时匹配，方法就是>扩展link的含义，给它加一维，贮存与星球匹配的所有人。
          link[]含义扩展了，接下来就扩展匈牙利算法，原始的二分图最>大匹配匈牙利算法在找未盖点i的增广路时，对于其邻接点j，若j也是未盖点
，则i,j匹配，否则尝试删除<link[j], j> 边，向上找增广路，如果找到了>，则i,j匹配，link[j] = i.  
          现在扩展成若星球j已匹配的人数 < capacity[j]，则人类i加到>其匹配列表里，即link[j].push_back(i)，否则尝试删除星球j的已匹配边<j, k>，从k向上寻找增广路，若找到，则用i代替k的位置link[j][k] = i;
bool find(int u)
{
    for(int v = 0; v < m; v++) if(path[u][v] && visit[v] == false){
        visit[v] = true;
        if(link[v][0] < cap[v]) {
            link[v][++link[v][0]] = v;
            return true;
        }
        for(int i = 1; i <= link[v][0]; i++)
            if(find(link[v][i])) {
                link[v][i] = u;
                return true;
            }
   }
   return false;
}
*/
(2) 二分图最大匹配  经典题  hdu_1045
/*
    题意：一张nxn的图，图上有的格子有东西挡着，问一个在图上最多放几
个炮台能覆盖整张图，且不会火力部重叠。若两个格子同行或同列且中间没>有东西挡住的话就会重叠。

    思路：经典二分图最大匹配，让我对格子二分图匹配有了更好的理解。
          建图：依然还是行元素在二分图的X部，列元素在Y部。不同的是>，因为有'#'阻断元素的存在，若某一行被'#'分成两部分，则要把该行分成>两部分，对应于二分图的话就是拆成两个点，当然都属于X部。分成几部分就
是几个点。
          列元素同理。
          代码里面用count-row和count_col统计行/列元素个数。其实就是
把n*n分成多少个区间。
*/
(3) 二分图带权匹配   最小权匹配  poj_2195
/*

    题意：n*m格子里，若干个小人&&房子，小人必须选一个房子进去，一个
房子只能容纳一个小人，问小人们选择各自的房子使得总路程最小.

    思路：二分图最小权匹配，转换为最大权匹配:
          不存在的边取无穷大，存在的边取反。LX[]初始化为无穷小。最>后答案取反。


          完备匹配即所有X部或Y部的点都匹配成功，而最优匹配肯定是完>备匹配，这道题可以虚拟出一些点使得|X| = |Y|，而因为题目明确了小人的
数量小于等于房子数，所以可以直接求小人的完备匹配，不用虚拟点出来。
*/

(4) /*
    poj 3686
    二分图带权匹配   拆点    好题

    题意：m家工厂，n个玩具订单，An*m矩阵描述j号工厂生产i号订单的话所需时间，同一时间内一工厂只能生产一个订单的玩具，问加工完所有玩具所话
费的时间的最小平均值（话费之间包括等待时间---如果有两个订单在同一家工厂里生产的话，第二个等第一个订单做完所花费的时间）

    思路：做专题的时候看到拆点，于是自然想到把m个工厂拆成m*n个点，但是因为题目要算等待时间，所以就不知道怎么建图。

          看题解知道，若有t1,t2,t3号玩具订单要依次在f号工厂做，则所花费的时间 = t1 + (t1+t2) + (t1+t2+t3)，而巧妙就巧妙在这里，***这个式
子可以再变换成 3*t1 + 2*t2 + t3  ***
          到这里换个思维建图，把订单执行的顺序反过来思考，这里用exec_time[f]来表示f上总花费时间：若t3订单最后一个执行，则exec_time[fac]>里面只包括一个t3。若t2是倒数第二个执行，则exec_time[f]包括2*t2 ... 扩展开，订单t在工厂f作为倒数第k个执行，则花费时间k*t[i][f]
          这是一个很重要也很妙的一点，抓住题目只要求“平均值”，也就是总和，对于工厂f，t1 + (t1+t2) + (t1+t2+t3)和3*t1 + 2*t2 + t3是相等的
，就是要求我们打破常规思维，***为什么我们一定要把某订单的执行时间看成一个整体呢？*** 题目只要求总时间和，常规思维的话要考虑“该订单前面有
谁”，而现在把时间总和的计算公式变成了第二种形式后，我们就只要考虑“改订单是第几个执行”，有种DP里通过变换获得了无后效性。
          太棒了，简单的变换反映了思维角度的变换，使得我们要考虑的问题变得简单了，只要考虑“我在第几”而非“前面是谁”。

          建图：还是把工厂拆成n*m个点, X部某点i, Y部某个点j，边权i-->j没有实际意义，所以我无法描述他们的意义，只能还是要上面的式子来说明
，edge[i-->j] = k * t[i][f], 其中k表i为倒数第k个在f工厂执行。
                由于拆点后对于同一订单，k*t[i][f] > (k-1)*t[i][f] > ... > 1*t[i][f]，所以能保证最优匹配一定是最小总和。


    二分图多重匹配类型题把匈牙利算法扩展到多对一
    这道题把KM算法扩展到能加上`顺序`元素
*/
